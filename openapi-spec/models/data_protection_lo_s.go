// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// DataProtectionLoS DataProtectionLoS describes a replica that protects data from loss. The requirements must be met collectively by the communication path and the replica.
// swagger:model DataProtectionLoS
type DataProtectionLoS struct {

	// recovery geographic objective
	// Enum: [Datacenter Rack RackGroup Region Row Server]
	RecoveryGeographicObjective string `json:"RecoveryGeographicObjective,omitempty"`

	// recovery point objective time
	RecoveryPointObjectiveTime string `json:"RecoveryPointObjectiveTime,omitempty"`

	// recovery time objective
	// Enum: [OnlineActive OnlinePassive Nearline Offline]
	RecoveryTimeObjective string `json:"RecoveryTimeObjective,omitempty"`

	// replica type
	// Enum: [Clone Mirror Snapshot TokenizedClone]
	ReplicaType string `json:"ReplicaType,omitempty"`

	// is isolated
	IsIsolated bool `json:"isIsolated,omitempty"`

	// min lifetime
	MinLifetime string `json:"minLifetime,omitempty"`
}

// Validate validates this data protection lo s
func (m *DataProtectionLoS) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateRecoveryGeographicObjective(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecoveryTimeObjective(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReplicaType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataProtectionLoSTypeRecoveryGeographicObjectivePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Datacenter","Rack","RackGroup","Region","Row","Server"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataProtectionLoSTypeRecoveryGeographicObjectivePropEnum = append(dataProtectionLoSTypeRecoveryGeographicObjectivePropEnum, v)
	}
}

const (

	// DataProtectionLoSRecoveryGeographicObjectiveDatacenter captures enum value "Datacenter"
	DataProtectionLoSRecoveryGeographicObjectiveDatacenter string = "Datacenter"

	// DataProtectionLoSRecoveryGeographicObjectiveRack captures enum value "Rack"
	DataProtectionLoSRecoveryGeographicObjectiveRack string = "Rack"

	// DataProtectionLoSRecoveryGeographicObjectiveRackGroup captures enum value "RackGroup"
	DataProtectionLoSRecoveryGeographicObjectiveRackGroup string = "RackGroup"

	// DataProtectionLoSRecoveryGeographicObjectiveRegion captures enum value "Region"
	DataProtectionLoSRecoveryGeographicObjectiveRegion string = "Region"

	// DataProtectionLoSRecoveryGeographicObjectiveRow captures enum value "Row"
	DataProtectionLoSRecoveryGeographicObjectiveRow string = "Row"

	// DataProtectionLoSRecoveryGeographicObjectiveServer captures enum value "Server"
	DataProtectionLoSRecoveryGeographicObjectiveServer string = "Server"
)

// prop value enum
func (m *DataProtectionLoS) validateRecoveryGeographicObjectiveEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataProtectionLoSTypeRecoveryGeographicObjectivePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataProtectionLoS) validateRecoveryGeographicObjective(formats strfmt.Registry) error {

	if swag.IsZero(m.RecoveryGeographicObjective) { // not required
		return nil
	}

	// value enum
	if err := m.validateRecoveryGeographicObjectiveEnum("RecoveryGeographicObjective", "body", m.RecoveryGeographicObjective); err != nil {
		return err
	}

	return nil
}

var dataProtectionLoSTypeRecoveryTimeObjectivePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["OnlineActive","OnlinePassive","Nearline","Offline"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataProtectionLoSTypeRecoveryTimeObjectivePropEnum = append(dataProtectionLoSTypeRecoveryTimeObjectivePropEnum, v)
	}
}

const (

	// DataProtectionLoSRecoveryTimeObjectiveOnlineActive captures enum value "OnlineActive"
	DataProtectionLoSRecoveryTimeObjectiveOnlineActive string = "OnlineActive"

	// DataProtectionLoSRecoveryTimeObjectiveOnlinePassive captures enum value "OnlinePassive"
	DataProtectionLoSRecoveryTimeObjectiveOnlinePassive string = "OnlinePassive"

	// DataProtectionLoSRecoveryTimeObjectiveNearline captures enum value "Nearline"
	DataProtectionLoSRecoveryTimeObjectiveNearline string = "Nearline"

	// DataProtectionLoSRecoveryTimeObjectiveOffline captures enum value "Offline"
	DataProtectionLoSRecoveryTimeObjectiveOffline string = "Offline"
)

// prop value enum
func (m *DataProtectionLoS) validateRecoveryTimeObjectiveEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataProtectionLoSTypeRecoveryTimeObjectivePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataProtectionLoS) validateRecoveryTimeObjective(formats strfmt.Registry) error {

	if swag.IsZero(m.RecoveryTimeObjective) { // not required
		return nil
	}

	// value enum
	if err := m.validateRecoveryTimeObjectiveEnum("RecoveryTimeObjective", "body", m.RecoveryTimeObjective); err != nil {
		return err
	}

	return nil
}

var dataProtectionLoSTypeReplicaTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Clone","Mirror","Snapshot","TokenizedClone"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataProtectionLoSTypeReplicaTypePropEnum = append(dataProtectionLoSTypeReplicaTypePropEnum, v)
	}
}

const (

	// DataProtectionLoSReplicaTypeClone captures enum value "Clone"
	DataProtectionLoSReplicaTypeClone string = "Clone"

	// DataProtectionLoSReplicaTypeMirror captures enum value "Mirror"
	DataProtectionLoSReplicaTypeMirror string = "Mirror"

	// DataProtectionLoSReplicaTypeSnapshot captures enum value "Snapshot"
	DataProtectionLoSReplicaTypeSnapshot string = "Snapshot"

	// DataProtectionLoSReplicaTypeTokenizedClone captures enum value "TokenizedClone"
	DataProtectionLoSReplicaTypeTokenizedClone string = "TokenizedClone"
)

// prop value enum
func (m *DataProtectionLoS) validateReplicaTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataProtectionLoSTypeReplicaTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataProtectionLoS) validateReplicaType(formats strfmt.Registry) error {

	if swag.IsZero(m.ReplicaType) { // not required
		return nil
	}

	// value enum
	if err := m.validateReplicaTypeEnum("ReplicaType", "body", m.ReplicaType); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataProtectionLoS) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataProtectionLoS) UnmarshalBinary(b []byte) error {
	var res DataProtectionLoS
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
